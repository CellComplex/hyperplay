<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<script>

var MirrorType = { SPHERE:1, PLANE:2, POINT:3 };

function p3( x, y, z ) { return { x:x, y:y, z:z }; }
function p2( x, y ) { return { x:x, y:y }; }
function add( a, b ) { return p3( a.x + b.x, a.y + b.y, a.z + b.z ); }
function sub( a, b ) { return p3( a.x - b.x, a.y - b.y, a.z - b.z ); }
function mul( a, f ) { return p3( a.x * f, a.y * f, a.z * f ); }
function dot( a, b ) { return a.x * b.x + a.y * b.y + a.z * b.z; }
function len2( a ) { return dot(a,a); }
function dist( a, b ) { return Math.sqrt( len2( sub( a, b ) ) ); }
function assign( a, b ) { a.x = b.x; a.y = b.y; a.z = b.z; }
function normalize( a ) { return mul( a, 1 / Math.sqrt( len2( a ) ) ); }
function cross( a, b ) { return p3( a.y * b.z - a.z * b.y, a.z*b.x - a.x * b.z, a.x * b.y - a.y * b.x ); }
function circle_radius( a, b, c ) { return a*b*c / Math.sqrt( (a+b+c)*(-a+b+c)*(a-b+c)*(a+b-c) ); } // triangle with side lengths a,b,c

var canvas;
var ctx;
var f;
var scale;
var translate;

function reflect( p, mirror ) {
    switch( mirror.type ) {
        case MirrorType.SPHERE:
            return sphereInversion( p, mirror );
        case MirrorType.PLANE:
            return planeReflection( p, mirror );
        case MirrorType.POINT:
            return pointReflection( p, mirror );
    }
}

function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return p2( evt.clientX - rect.left, evt.clientY - rect.top );
}

function onMouseMove( evt ) {
    var pos = getMousePos( canvas, evt );
    f = ( pos.x - canvas.width/2 ) * 0.5;
    redraw();
}

function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');

    f = 1.0;
    scale = 100.0;
    translate = p3( canvas.width/2, canvas.height/2, 0 );
    redraw();

    canvas.addEventListener( 'mousemove', onMouseMove, false );
}

function sphereInversion( p, sphere ) {
    var d2 = len2( sub( p, sphere.p ) );
    return add( sphere.p, mul( sub( p, sphere.p ), sphere.r2 / d2 ) );
}

function planeReflection( p, plane ) {
    var pn = dot( plane.n, sub( p, plane.p ) );
    var proj = sub( p, mul( plane.n, pn ) );
    return add( proj, sub( proj, p ) );
}

function pointReflection( p, point ) {
    return add( point.p, sub( point.p, p ) );
}

function fromHyperbola( p ) {
    // from the unit hyperbola a=b=1 centered at the origin, to the x-axis
    return p3( p.x / ( 1.0 + p.y ), 0, 0 );
}

function toHyperbola( p ) {
    // from the x-axis to the unit hyperbola a=b=1 centered at the origin
    return p3( 2.0*p.x/(1.0-p.x*p.x), (1.0+p.x*p.x)/(1.0-p.x*p.x), 0 );
}

function toOurHyperbola( p, o, R ) {
    // p should lie on the x-axis
    var hp = toHyperbola( p3( 0.5 * p.x / R, 0, 0 ) );
    hp.y *= -1;
    return add( mul( hp, R ), o );
}

function fromOurHyperbola( p, o, R ) {
    var hp = mul( sub( p, o ), 1.0 / R );
    hp.y *= -1;
    var ap = fromHyperbola( hp );
    return p3( 2.0 * R * ap.x, 0, 0 );
}

function moveTo( a ) { ctx.moveTo( a.x*scale + translate.x, translate.y - a.y*scale ); }
function lineTo( a ) { ctx.lineTo( a.x*scale + translate.x, translate.y - a.y*scale ); }
function line( a, b ) { 
    ctx.beginPath();
    moveTo( a );
    lineTo( b );
    ctx.stroke();
}
function circle( c, R ) { ctx.beginPath(); ctx.arc( c.x*scale + translate.x, translate.y - c.y*scale, Math.abs(R)*scale, 0, 2.0 * Math.PI ); ctx.stroke(); }
function point( p, t ) { 
    ctx.beginPath(); 
    ctx.arc( p.x*scale + translate.x, translate.y - p.y*scale, 2, 0, 2.0 * Math.PI ); 
    if( t )
        ctx.fillText( t, p.x*scale + translate.x + 3, translate.y - p.y*scale - 3 );
    ctx.fill(); 
}

function redraw() {
    var blackFillStyle = "rgb(0,0,0)";
    var thinLineStyle = "rgba(0,0,0,0.3)";
    var homeLineStyle = "rgba(180,180,0,1)";
    var homeFillStyle = "rgba(180,180,0,0.05)";
    var redLineStyle = "rgb(255,0,0)";
    var blueLineStyle = "rgb(0,127,255)";
    var greenLineStyle = "rgb(0,127,0)";
    var lightGreenLineStyle = "rgba(0,255,0,0.5)";
    var pinkLineStyle = "rgb(255,127,127)";
    var cyanLineStyle = "rgb(0,255,255)";
    
    ctx.strokeStyle = thinLineStyle;
    ctx.lineWidth = 1;
    ctx.font="12px Verdana";
    
    ctx.clearRect( 0, 0, canvas.width, canvas.height );
    ctx.strokeRect( 0, 0, canvas.width, canvas.height );
    
    // draw the base line
    line( p3(-100,0,0), p3(100,0,0) );

    var R = 1.0 / f;
    R *= 100;
    
    var c = p3(0,0,0);
    point( c, 'C' );
    var a = p3(0.7,0,0);
    point( a, 'A' );

    // construct a circle where things live sometimes oh heck it must have a name
    var o = p3(0,R,0);
    point( o, 'O' );
    if( R > 0 )
        ctx.strokeStyle = homeLineStyle; // for positive curvature this circle is our home surface
    circle( o, R );
    if( R > 0 ) {
        ctx.fillStyle = homeFillStyle;
        ctx.fill();
        ctx.fillStyle = blackFillStyle;
        ctx.strokeStyle = thinLineStyle;
    }
    
    // construct the inversion circle that we can use to project stereographically to and from the circle
    var SR = 2.0 * R;
    var s = p3( 0, SR, 0 );
    var inversion = { type:MirrorType.SPHERE, p:s, r2:SR*SR };
    //circle( s, SR );
    point( s, 'S' );

    var central_mirror = { type:MirrorType.PLANE, p:c, n:p3(1,0,0) };
      
    var b,d,m;
    if( R > 0 ) {
        b = reflect( a, inversion );
        // construct other points on the mirror using the geodesic on the sphere
        d = add( o, sub( o, b ) );
        m = reflect( d, inversion );
        
        line( s, m );
        line( a, s );
    }
    else {
        var w = p3(-2*R,0,0); 
        var e = p3(2*R,0,0); 
        point( w,'W');
        point( e,'E');
        line( s, e );
        line( s, w );

        // draw the hyperbola itself
        var step = 0.01;
        ctx.fillStyle = homeFillStyle;
        ctx.strokeStyle = homeLineStyle;
        ctx.beginPath();
        var x = -1+step;
        var e1 = toHyperbola( p3( x-step/2,0,0) );
        e1 = mul( e1, R );
        moveTo( e1 );
        for( ; x <= 1-step; x+=step ) {
            var e2 = toHyperbola( p3( x+step/2,0,0) );
            e2 = mul( e2, R );
            lineTo( add( e2, o ) );
        }
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        x = -1+step;
        e1 = toHyperbola( p3( x-step/2,0,0) );
        e1 = mul( e1, R );
        e1 = p3( e1.x, -e1.y, e1.z );
        moveTo( e1 );
        for( ; x <= 1-step; x+=step ) {
            var e2 = toHyperbola( p3( x+step/2,0,0) );
            e2 = mul( e2, R );
            e2 = p3( e2.x, -e2.y, e2.z );
            lineTo( add( e2, o ) );
        }
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = blackFillStyle;
        ctx.strokeStyle = thinLineStyle;
        line( p3(o.x-R,o.y,o.z), p3(o.x+R,o.y,o.z) ); // the Klein plane
        
        b = toOurHyperbola( a, o, R );
        
        // construct other points on the mirror using the geodesic on the hemisphere model
        d = add( o, sub( o, b ) );
        m = fromOurHyperbola( d, o, R );
        
        ctx.lineWidth = 1;
        ctx.strokeStyle = thinLineStyle;
        line( b, s );
        line( d, m );
    }
    
    // draw the plane through that point and the origin that makes a geodesic on the hyperbola
    ctx.lineWidth = 1;
    ctx.strokeStyle = lightGreenLineStyle;
    line( sub( o, mul( sub( b, o ), 100 ) ), add( o, mul( sub( b, o ), 100 ) ) ); // B-O-D
    point( b, 'B' );
    
    // draw the other side of the mirror and its projection
    ctx.lineWidth = 1;
    ctx.strokeStyle = thinLineStyle;
    point( d, 'D' );
    point( m, 'M' );
    
    ctx.strokeStyle = redLineStyle;
    ctx.lineWidth = 2;
    line( c, a );
    line( b, c );
    
    // construct the inversion circle for the mirror at a, and reflect c onto g
    var k = mul( add( a, m ), 0.5 ); // center of the inversion sphere
    var mirror = { type:MirrorType.SPHERE, p:k, r2:Math.pow( dist( a, k ), 2 ) };
    point( k );
    var g = reflect( c, mirror );
    ctx.strokeStyle = blueLineStyle;
    ctx.lineWidth = 2;
    line( a, g );
    point( g, 'G' );
    var u = reflect( a, central_mirror );
    var v = reflect( g, central_mirror );
    var w = reflect( u, mirror );
    var y = reflect( w, central_mirror );
    ctx.strokeStyle = greenLineStyle;
    line( c, u );
    ctx.strokeStyle = pinkLineStyle;
    line( u, v );
    line( g, w );
    ctx.strokeStyle = cyanLineStyle;
    line( v, y );
    // project points onto the surface
    var gp,vp,up,wp;
    if( R > 0 ) {
        gp = reflect( g, inversion );
        up = reflect( u, inversion );
        vp = reflect( v, inversion );
        wp = reflect( w, inversion );
        yp = reflect( y, inversion );
    }
    else {
        gp = toOurHyperbola( g, o, R );
        up = toOurHyperbola( u, o, R );
        vp = toOurHyperbola( v, o, R );
        wp = toOurHyperbola( w, o, R );
        yp = toOurHyperbola( y, o, R );
    }
    ctx.lineWidth = 2;
    ctx.strokeStyle = blueLineStyle;
    line( b, gp );
    ctx.strokeStyle = greenLineStyle;
    line( c, up );
    ctx.strokeStyle = pinkLineStyle;
    line( up, vp );
    line( gp, wp );
    ctx.strokeStyle = cyanLineStyle;
    line( vp, yp );
    
    ctx.lineWidth = 1;
    ctx.strokeStyle = thinLineStyle;
    line( g, gp );
    line( u, up );
    line( v, vp );
    line( w, wp );
    line( y, yp );
}

window.onload = init;
</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

</head>

<body>

<p align="center"><canvas id="canvas" width="1000" height="700">(Canvas drawing not supported by your browser.)</canvas></p>

</html>

