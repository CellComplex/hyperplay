<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<script>

var MirrorType = { SPHERE:1, PLANE:2, POINT:3 };

function p3( x, y, z ) { return { x:x, y:y, z:z }; }
function add( a, b ) { return p3( a.x + b.x, a.y + b.y, a.z + b.z ); }
function sub( a, b ) { return p3( a.x - b.x, a.y - b.y, a.z - b.z ); }
function mul( a, f ) { return p3( a.x * f, a.y * f, a.z * f ); }
function dot( a, b ) { return a.x * b.x + a.y * b.y + a.z * b.z; }
function len2( a ) { return dot(a,a); }
function dist( a, b ) { return Math.sqrt( len2( sub( a, b ) ) ); }
function assign( a, b ) { a.x = b.x; a.y = b.y; a.z = b.z; }
function normalize( a ) { return mul( a, 1 / Math.sqrt( len2( a ) ) ); }
function cross( a, b ) { return p3( a.y * b.z - a.z * b.y, a.z*b.x - a.x * b.z, a.x * b.y - a.y * b.x ); }
function circle_radius( a, b, c ) { return a*b*c / Math.sqrt( (a+b+c)*(-a+b+c)*(a-b+c)*(a+b-c) ); } // triangle with side lengths a,b,c

var canvas;
var ctx;
var scale;
var translate;
var mp = p3(0,0,0);

function reflect( p, mirror ) {
    switch( mirror.type ) {
        case MirrorType.SPHERE:
            return sphereInversion( p, mirror );
        case MirrorType.PLANE:
            return planeReflection( p, mirror );
        case MirrorType.POINT:
            return pointReflection( p, mirror );
    }
}

function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return p3( evt.clientX - rect.left, evt.clientY - rect.top, 0 );
}

function onMouseMove( evt ) {
    mp = getMousePos( canvas, evt );
    redraw();
}

function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');

    scale = 50.0;
    translate = p3( canvas.width/2, canvas.height/2, 0 );
    redraw();

    canvas.addEventListener( 'mousemove', onMouseMove, false );
}

function sphereInversion( p, sphere ) {
    var d2 = len2( sub( p, sphere.p ) );
    return add( sphere.p, mul( sub( p, sphere.p ), sphere.r2 / d2 ) );
}

function planeReflection( p, plane ) {
    var pn = dot( plane.n, sub( p, plane.p ) );
    var proj = sub( p, mul( plane.n, pn ) );
    return add( proj, sub( proj, p ) );
}

function pointReflection( p, point ) {
    return add( point.p, sub( point.p, p ) );
}

function fromHyperbola( p ) {
    // from the unit hyperbola a=b=1 centered at the origin, to the x-axis
    return p3( p.x / ( 1.0 + p.y ), 0, 0 );
}

function toHyperbola( p ) {
    // from the x-axis to the unit hyperbola a=b=1 centered at the origin
    return p3( 2.0*p.x/(1.0-p.x*p.x), (1.0+p.x*p.x)/(1.0-p.x*p.x), 0 );
}

function toOurHyperbola( p, o, R ) {
    // p should lie on the x-axis
    var hp = toHyperbola( p3( 0.5 * p.x / R, 0, 0 ) );
    hp.y *= -1;
    return add( mul( hp, R ), o );
}

function fromOurHyperbola( p, o, R ) {
    var hp = mul( sub( p, o ), 1.0 / R );
    hp.y *= -1;
    var ap = fromHyperbola( hp );
    return p3( 2.0 * R * ap.x, 0, 0 );
}

function moveTo( a ) { ctx.moveTo( a.x*scale + translate.x, translate.y - a.y*scale ); }
function lineTo( a ) { ctx.lineTo( a.x*scale + translate.x, translate.y - a.y*scale ); }
function line( a, b ) { 
    ctx.beginPath();
    moveTo( a );
    lineTo( b );
    ctx.stroke();
}
function circle( c, R ) { ctx.beginPath(); ctx.arc( c.x*scale + translate.x, translate.y - c.y*scale, Math.abs(R)*scale, 0, 2.0 * Math.PI ); ctx.stroke(); }
function point( p, t ) { 
    ctx.beginPath(); 
    ctx.arc( p.x*scale + translate.x, translate.y - p.y*scale, 2, 0, 2.0 * Math.PI ); 
    if( t )
        ctx.fillText( t, p.x*scale + translate.x + 3, translate.y - p.y*scale - 3 );
    ctx.fill(); 
}

function reciprocal_of_line( C, L ) {
    // return the polar of line L in respect to circle C
    // (the inverse of the closest point on L to C)
    // base b is along the line normal from C, where it intersects the line
    var b = add( C.p, mul( L.n, dot( sub( L.p, C.p ), L.n ) ) );
    return sphereInversion( b, C );
}

function reciprocal_of_point( C, p ) {
    // return the polar of point p in respect to circle C
    // (the perpendicular through the inverse of P)
    var b = sphereInversion( p, C );
    return { type:MirrorType.PLANE, p:b, n:normalize(sub(p,C.p)) };
}

function redraw() {

    ctx.strokeStyle = "rgba(0,0,0,0.3)";

    ctx.clearRect( 0, 0, canvas.width, canvas.height );
    ctx.strokeRect( 0, 0, canvas.width, canvas.height );
   
    // define our circle of reciprocation
    var r1 = 2;
    var C = { type:MirrorType.SPHERE, p:p3(0,0,0), r2:r1*r1 };
    circle( C.p, Math.sqrt(C.r2) );
    point( C.p );
    
    // find the pole of each tangent of a circle
    var r = 1;
    var wmp = mul(sub(mp,translate),1.0/scale);
    wmp.y *= -1;
    var C2 = { type:MirrorType.SPHERE, p:wmp, r2:r*r };
    circle( C2.p, r );
    var step = 2.0 * Math.PI / 100.0;
    for( var i = 0; i < 100; ++i ) {
        var theta = i * step; 

        // find the point on the circle and its normal, defining a tangent
        var p = p3( C2.p.x + r*Math.cos(theta), C2.p.y + r*Math.sin(theta ), 0 );
        ctx.fillStyle = "rgb(0,127,0)";
        point( p );
        var L = {type:MirrorType.PLANE, p:p, n:normalize(sub(p,C2.p)) };
        
        // find the pole of the tangent line in circle C
        ctx.fillStyle = "rgb(0,0,0)";
        var RP = reciprocal_of_line( C, L );
        point( RP );
        
        // for fun also draw the inversion of the same point on C2
        ctx.fillStyle = "rgba(255,0,0,0.2)";
        var IP = sphereInversion( p, C );
        point( IP );

        // also draw the inversion of RP
        ctx.fillStyle = "rgba(0,0,255,0.2)";
        var TP = sphereInversion( RP, C );
        point( TP );
        
        if( i==20 ) {
            line( p, TP );
            line( TP, RP );
        }
    }
}

window.onload = init;
</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

</head>

<body>

<p align="center"><canvas id="canvas" width="1000" height="700">(Canvas drawing not supported by your browser.)</canvas></p>

<ul>
<li>In the center is a fixed unit circle S. Your mouse controls a second circle C of green dots.
<li>The red dots are the inversion of C in S.
<li>The blue dots are the points where the tangents of C come closest to S. A line shows one such tangent, joining a green dot with a blue dot.
<li>The black dots are the inversion of the blue dots. A line joins our blue point to its matching black one.
</ul>

</html>

