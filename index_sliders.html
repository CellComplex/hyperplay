<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<script>

var MirrorType = { SPHERE:1, PLANE:2, POINT:3 };

function p3( x, y, z ) { return { x:x, y:y, z:z }; }
function p2( x, y ) { return { x:x, y:y }; }
function origin() { return p3(0,0,0); }
function xaxis() { return p3(1,0,0); }
function yaxis() { return p3(0,1,0); }
function zaxis() { return p3(0,0,0); }
function add( a, b ) { return p3( a.x + b.x, a.y + b.y, a.z + b.z ); }
function sub( a, b ) { return p3( a.x - b.x, a.y - b.y, a.z - b.z ); }
function mul( a, f ) { return p3( a.x * f, a.y * f, a.z * f ); }
function dot( a, b ) { return a.x * b.x + a.y * b.y + a.z * b.z; }
function len2( a ) { return dot(a,a); }
function dist( a, b ) { return Math.sqrt( len2( sub( a, b ) ) ); }
function assign( a, b ) { a.x = b.x; a.y = b.y; a.z = b.z; }
function normalize( a ) { return mul( a, 1 / Math.sqrt( len2( a ) ) ); }
function cross( a, b ) { return p3( a.y * b.z - a.z * b.y, a.z*b.x - a.x * b.z, a.x * b.y - a.y * b.x ); }
function sphere_radius_from_line_and_two_points( a, b, p1, p2 ) {
    // What is the radius of the sphere which has center on a line a-b and surface passing through points p1 and p2?
    // Find the intersection between the line and the plane halfway between p1 and p2 (we assume a solution exists)
    var mp = mul( add( p1, p2 ), 0.5 );
    var pn = sub( p1, p2 );
    var ln = sub( b, a );
    // at the intersection c of the line and the plane we know that a + t*ln = c and ( c - mp ).pn = 0
    // hence ( a + t*ln - mp ).pn = 0
    // hence t*ln.pn + (a-mp).pn = 0
    // hence t = (mp-a).pn / ln.pn
    var t = dot( sub( mp, a ), pn ) / dot( ln, pn );
    var c = add( a, mul( ln, t ) );
    return dist( c, p1 ); // check: dist(c,p1)==dist(c,p2)
}

var depth;
var mirror_lists;
var mesh;
var theta;
var camera;
var sliders;
var iActiveSlider;
var curvatureRange = 5;
var isSpinning = true;
var showStereographically = false;

function curvatureFromSliderPos( v ) { return ( v - 0.5 ) * curvatureRange; }
function sliderPosFromCurvature( f ) { return f / curvatureRange + 0.5; }

function getMirrorLists( N, d ) {
    // returns e.g (N=3,d=2) [ [], [0], [1], [2], [0,1], [0,2], [1,0], [1,2], [2,0], [2,1] ]
    // where no consecutive mirror repeats (would just put us back where we were)
    var mirror_lists = [[]];
    var iList = 0;
    for( var iDepth = 0; iDepth < d; ++iDepth ) {
        var num_lists = mirror_lists.length;
        for( ; iList < num_lists; ++iList ) {
            for( iExtraMirror = 0; iExtraMirror < N; ++iExtraMirror ) {
                if( iExtraMirror == mirror_lists[iList][ mirror_lists[iList].length-1 ] ) continue;
                var extended_list = mirror_lists[iList].slice();
                extended_list.push( iExtraMirror );
                mirror_lists.push( extended_list );
            }
        }
    }
    return mirror_lists;
}

function reflect( p, mirror ) {
    switch( mirror.type ) {
        case MirrorType.SPHERE: return sphereInversion( p, mirror );
        case MirrorType.PLANE:  return planeReflection( p, mirror );
        case MirrorType.POINT:  return pointReflection( p, mirror );
    }
}

function getInversionRadiusForStereographicPolygon( pc, p, R ) {
    // If you've got a point p on the x-axis with midpoint pc that you want to use as a mirror to make a stereographic projection of
    // a polygon in a second dimension, with radius R, what is the 1D projection of the inversion circle needed?
    
    // We need to construct another point that lies on the polygon mirror for that vertex. What is the mirror? 
    // The vertex on the polygon's circumcircle defines a reflection across the line passing through that point 
    // and the circle center. The only other point on the mirror is where the line intersects the circle on the other side.
    
    // One complication is that the point p is already on the circumcircle, not on the stereographic plane, and we want the answer in the
    // same plane as the input. But changing planes is just a matter of linear scaling.
    
    var v = dist( pc, p );
    var h = Math.sqrt( R*R - v*v );
    var c = p3( pc.x, h, 0 ); // center of polygon circumcircle
    var SR = 2.0 * R;
    var sc = p3( pc.x, h+R, 0 ); // stereographic center is the north pole of the polygon circumcircle
    var stereographic_mirror = { type:MirrorType.SPHERE, p:sc, r2:SR*SR }; 
    var point_mirror = { type:MirrorType.POINT, p:c };
    var p_antipodal = reflect( reflect( p, point_mirror ), stereographic_mirror );
    // but p_antipodal lies on the stereographic plane - we need it on the input plane (linear scaling)
    p_antipodal = add( sc, mul( sub( p_antipodal, sc ), (h+R) / (R+R) ) );
    var r = dist( p, p_antipodal ) / 2.0;
}

function getInversionRadiusForStereographicPolyhedron( pc, p1, p2, R ) {
    // If you've got an edge p1-p2 of a polygon with center pc on the xy-plane that you want to use as a mirror to make a 
    // stereographic projection of a polyhedron in a third dimension, with radius R, what is the radius of the inversion circle needed?
    
    // We need to construct another point that lies on the mirror. What is the mirror? The edge on the polyhedron's circumsphere
    // defines a reflection across the plane passing through the edge and the sphere's center. The intersection of this plane with
    // the sphere is a great circle. Projecting that circle onto the stereographic plane gives the inversion circle we need.
    
    // There are lots of ways of working out what that circle is. One is to reflect one of the points across the sphere's center to the antipodal point
    // and then project it back onto the plane.
    
    // One complication is that the point p1 is already on the circumcircle, not on the stereographic plane, and we want the answer in the
    // same plane as the input. But changing planes is just a matter of linear scaling.
    
    // We reflect p1 across the sphere center, then project back onto the plane. This gives us two points and a line so we can find the 
    // radius of the inversion circle.
    var v = dist( pc, p1 );
    var h = Math.sqrt( R*R - v*v );
    var c  = p3( pc.x, pc.y, h ); // check: dist(c,p1)==dist(c,p2)==R
    var sc = p3( pc.x, pc.y, h+R );
    var SR = 2.0 * R; // stereographic projection is inversion in a sphere of twice the radius
    var stereographic_mirror = { type:MirrorType.SPHERE, p:sc, r2:SR*SR }; 
    var point_mirror = { type:MirrorType.POINT, p:c };
    var p1_antipodal = reflect( reflect( p1, point_mirror ), stereographic_mirror );
    p1_antipodal = add( sc, mul( sub( p1_antipodal, sc ), ( h + R ) / ( R + R ) ) ); // scale back onto input plane
    // we now have a center line and two points for the circle, what is its radius?
    var mp = mul( add( p1, p2 ), 0.5 );
    return sphere_radius_from_line_and_two_points( pc, mp, p1, p1_antipodal );
}

function getInversionRadiusForStereographicPolychoron( cc, c, p, R ) {
    // If you've got a polyhedron with center cc with a face, given by center c and a vertex p, that you want to use as a mirror to make a stereographic
    // projection of a polychoron in a fourth dimension, with radius R, what is the radius of the inversion sphere needed?
    
    // We need to construct another point that lies on the mirror (not on the polygon plane). Then two points and a line determine the inversion sphere.
    
    // We reflect p across the sphere center, then project back onto the input volume.
    // This gives us a second point on the inversion sphere we want, so we can fit a sphere and compute its radius.
    var v = dist( cc, p );
    var h = Math.sqrt( R*R - v*v );
    var ccc  = { x:cc.x, y:cc.y, z:cc.z, w:h   }; // check: dist(ccc,p)==R
    var sc = { x:cc.x, y:cc.y, z:cc.z, w:h+R };
    var SR = 2.0 * R; // stereographic projection is inversion in a sphere of twice the radius
    var stereographic_mirror = { type:MirrorType.SPHERE, p:sc, r2:SR*SR }; 
    var p_antipode_on_3sphere = { x:2.0*ccc.x-p.x, y:2.0*ccc.y-p.y, z:2.0*ccc.z-p.z, w:2.0*ccc.w };
    var p_antipode_on_stereographic_volume = sphereInversion4d( p_antipode_on_3sphere, stereographic_mirror ); // check: w=0
    var p_antipodal = add( sc, mul( sub( p_antipode_on_stereographic_volume, sc ), ( h + R ) / ( R + R ) ) ); // scale back onto input plane (uses only the 3d coordinates)
    // we now have a center line and two points for the sphere, what is its radius?
    return sphere_radius_from_line_and_two_points( cc, c, p, p_antipodal );
}

function makeMirror1D( p, f ) {
    // given an endpoint of a line segment centered at the origin and lying along the x-axis
    // return a suitable Wythoff mirror for space curvature f
    if( Math.abs( f ) < 1e-4 ) {
        // f=0 : infinite straight line reflections to make a 1D lattice
        return { type:MirrorType.PLANE, p:p, n:normalize(p) };
    }
    else if( f > 0 ) {
        var R = 1 / f;
        var using_stereographic_projection = false;
        if( using_stereographic_projection ) {
            // positive curvature, stereographic line: make an inversion sphere positioned along the x-axis but inwards from the endpoint
            var r_stereo = getInversionRadiusForStereographicPolygon( p3(0,0,0), p, R );
            var n = normalize( p );
            return { type:MirrorType.SPHERE, p:sub( p, mul( n, r_stereo ) ), r2:r_stereo*r_stereo };
        }
        else
        {
            // positive curvature: can make a polygon by reflecting at an angle
            var c = p3( 0, Math.sqrt( R*R - len2(p) ), 0 );
            var v = normalize( sub( p, c ) );
            return { type:MirrorType.PLANE, p:c, n:p3(-v.y,v.x,0) };
        }
    }
    else {
        // negative curvature, hyperbolic space: make an inversion sphere positioned further along the x-axis
        var R = 1 / f;
        var n = normalize( p );
        return { type:MirrorType.SPHERE, p:add( p, mul( n, R ) ), r2:R*R };
    }
}

function makeMirror2D( p1, p2, c, f ) {
    // given two vertices of an edge of a polygon on the xy-plane with center c
    // return a suitable Wythoff mirror for space curvature f
    if( Math.abs( f ) < 1e-4 ) {
        // f=0 : a flat mirror in the same plane
        var mid = mul( add( p1, p2 ), 0.5 );
        var n = normalize( sub( mid, c ) );
        return { type:MirrorType.PLANE, p:mid, n:n };
    }
    else if( f > 0 ) {
        var R = 1 / f; // the radius of the polyhedron circumsphere
        if( showStereographically ) {
            // positive curvature, stereographic plane: make an inversion sphere positioned to intersect the two vertices (in from the edge)
            var r_stereo = getInversionRadiusForStereographicPolyhedron( c, p1, p2, R );
            var mid = mul( add( p1, p2 ), 0.5 );
            var n = normalize( sub( mid, c ) );
            var d = Math.sqrt( r_stereo*r_stereo - len2( sub( p1, mid ) ) );
            var c2 = sub( mid, mul( n, d ) );
            return { type:MirrorType.SPHERE, p:c2, r2:r_stereo*r_stereo };
        }
        else {
            // positive curvature: can make a polyhedron by reflecting at an angle
            var mid = mul( add( p1, p2 ), 0.5 );
            var cn = normalize( cross( sub( p1, c ), sub( p2, c ) ) );
            var cR = Math.sqrt( R*R - len2( sub( p1, c ) ) );
            var c2 = add( c, mul( cn, cR ) );
            var n = normalize( cross( sub( p1, c2 ), sub( p2, c2 ) ) );
            return { type:MirrorType.PLANE, p:c2, n:n };
        }
    }
    else {
        // negative curvature, hyperbolic space: make an inversion sphere positioned to intersect the two vertices (away from the center)
        var R = 1 / f;
        var mid = mul( add( p1, p2 ), 0.5 );
        var n = normalize( sub( mid, c ) );
        var d = Math.sqrt( R*R - len2( sub( p1, mid ) ) );
        var c2 = add( mid, mul( n, d ) );
        return { type:MirrorType.SPHERE, p:c2, r2:R*R };
    }
}

function makeMirror3D( p, c, c2, f ) {
    // given a vertex p and the center c of a face on a polyhedron with center c2
    // return a suitable Wythoff mirror for space curvature f
    if( Math.abs( f ) < 1e-4 ) {
        // f=0 : a flat mirror in the same plane as the face
        var n = normalize( sub( c, c2 ) );
        return { type:MirrorType.PLANE, p:c, n:n };
    }
    else if( f > 0.0 ) {
        // positive curvature: make an inversion sphere positioned to intersect the vertices of the face, in towards the polyhedron center
        var R = 1 / f;
        var r_stereo = getInversionRadiusForStereographicPolychoron( c2, c, p, R );
        var n = normalize( sub( c, c2 ) );
        var d = Math.sqrt( r_stereo*r_stereo - len2( sub( p, c ) ) );
        var mc = sub( c, mul( n, d ) );
        return { type:MirrorType.SPHERE, p:mc, r2:r_stereo*r_stereo };
    }
    else
    {
        // negative curvature: make an inversion sphere positioned to intersect the vertices, away from the polyhedron center
        var R = 1 / f;
        var n = normalize( sub( c, c2 ) );
        var d = Math.sqrt( R*R - len2( sub( p, c ) ) );
        var mc = add( c, mul( n, d ) );
        return { type:MirrorType.SPHERE, p:mc, r2:R*R };
    }
}

function makeMesh() {
    // f is the curvature of space.
    // f=0 means flat Euclidean space. each mirror is a simple plane reflection.
    // f<0 means hyperbolic space, with circle inversion (we use the Poincare disk/ball model)
    // f>0 means spherical space, where a straight line is a great circle, hence a reflection is an out-of-plane reflection
    // if f<0 then R=-1/f is the radius of the spheres we will use for inversion
    // if f>0 then R=1/f is the radius of the sphere on which the world lives (determines the angle of the 3d plane we will use to reflect)

    var f1 = curvatureFromSliderPos( sliders[0].value );
    var f2 = curvatureFromSliderPos( sliders[1].value );
    var f3 = curvatureFromSliderPos( sliders[2].value );

    // start with a line segment in the center (embedded in R3)
    var edge_length = 1;
    var base_edge = [ p3(-edge_length/2,0,0), p3(edge_length/2,0,0) ];
    
    // make a mirror from each endpoint of the line segment
    var mirrors1D = [];
    for( var iVert = 0; iVert < base_edge.length; ++iVert )
        mirrors1D.push( makeMirror1D( base_edge[ iVert ], f1 ) );
    
    // make a polygon using the line segment and the mirrors, up to a certain depth
    // this case is a little different to the next ones, because we need a specific order to draw the edges
    // e.g. depth=3: m0(m1(m0(p1))), m0(m1(p0)), m0(p1), p0, p1, m1(p0), m1(m0(p1)), m1(m0(m1(p0)))
    var base_polygon = base_edge.slice();
    for( var iDepth = 0; iDepth < depth; ++iDepth ) {
        var a = reflect( base_polygon[ base_polygon.length-1 ], mirrors1D[ 0 ] );
        var b = reflect( base_polygon[ 0 ], mirrors1D[ 1 ] );
        base_polygon.splice( 0, 0, a );
        base_polygon.push( b );
    }
    
    if( f1 <= 0 ) {
        mesh = [ [ base_polygon ] ]; // stop at level 1 (a single polyhedron with a single polygon in it)
        return;
    }

    // make a 2D mirror from each edge of the polygon
    var polygon_center = mirrors1D[ 0 ].p; // (all the mirrors have the same center for f1 > 0)
    var mirrors2D = [];
    for( var iVert = 1; iVert < base_polygon.length; ++iVert )
        mirrors2D.push( makeMirror2D( base_polygon[ iVert-1 ], base_polygon[ iVert ], polygon_center, f2 ) );
    
    // make a 2D mesh using the polygon and the mirrors, up to a certain depth
    var base_polyhedron = [];
    var polygon_centers = [];
    for( var iList = 0; iList < mirror_lists.length; ++iList ) {
        var mirror_list = mirror_lists[ iList ];
        // reflect the polygon in this sequence of mirrors
        var new_polygon = [];
        for( var iVert = 0; iVert < base_polygon.length; ++iVert ) {
            var p = {};
            assign( p, base_polygon[ iVert ] );
            for( var iMirror = 0; iMirror < mirror_list.length; ++iMirror )
                assign( p, reflect( p, mirrors2D[ mirror_list[ iMirror ] ] ) );
            new_polygon[ iVert ] = p;
        }
        base_polyhedron.push( new_polygon );
        // also transform the center of the base_polygon, since we need it later
        var p = {};
        assign( p, polygon_center );
        for( var iMirror = 0; iMirror < mirror_list.length; ++iMirror )
            assign( p, reflect( p, mirrors2D[ mirror_list[ iMirror ] ] ) );
        polygon_centers.push( p );
    }
    
    if( f2 <= 0 ) {
        mesh = [ base_polyhedron ]; // stop at level 2 (a single polyhedron/tiling)
        return;
    }
    
    // make a mirror from each face of the polyhedron
    var polyhedron_center = mirrors2D[ 0 ].p; // (all the mirrors have the same center for f2 > 0)
    var mirrors3D = [];
    for( var iPolygon = 0; iPolygon < base_polyhedron.length; ++iPolygon ) {
        mirrors3D.push( makeMirror3D( base_polyhedron[ iPolygon ][0], polygon_centers[ iPolygon ], polyhedron_center, f3 ) );
    }
    
    // make a 3D mesh using the polyhedron and the mirrors, up to a certain depth
    mesh = [];
    for( var iList = 0; iList < mirror_lists.length; ++iList ) {
        var mirror_list = mirror_lists[ iList ];
        // reflect the polyhedron in this sequence of mirrors
        var new_polyhedron = [];
        for( var iPolygon = 0; iPolygon < base_polyhedron.length; ++iPolygon ) {
            var polygon = base_polyhedron[ iPolygon ];
            var new_polygon = [];
            for( var iVert = 0; iVert < polygon.length; ++iVert ) {
                var p = {};
                assign( p, polygon[ iVert ] );
                for( var iMirror = 0; iMirror < mirror_list.length; ++iMirror )
                    assign( p, reflect( p, mirrors3D[ mirror_list[ iMirror ] ] ) );
                new_polygon[ iVert ] = p;
            }
            new_polyhedron.push( new_polygon );
        }
        mesh.push( new_polyhedron );
    }
}

function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return p2( evt.clientX - rect.left, evt.clientY - rect.top );
}

function onMouseMove( evt ) {
    var pos = getMousePos( canvas, evt );
    if( iActiveSlider >= 0 ) {
        var slider = sliders[ iActiveSlider ];
        slider.value = Math.min( 1, Math.max( 0, ( pos.x - slider.x ) / slider.width ) );
        updateShareLink();
        makeMesh();
        redraw();
    }
}

function onMouseDown( evt ) {
    var pos = getMousePos( canvas, evt );
    for( var iSlider = 0; iSlider < sliders.length; ++iSlider ) {
        if( pointInRect( pos, sliders[ iSlider ].handle_rect ) ) {
            iActiveSlider = iSlider;
            return;
        }
    }
    isSpinning = !isSpinning;
    if( isSpinning ) animate();
}

function onMouseUp( evt ) {
    iActiveSlider = -1;
    redraw();
}

function repositionCamera() {
    var look_at = p3(0,0,0);
    var d = 6;
    camera.p = p3( d*Math.cos(theta), -1, d*Math.sin(theta) );
    camera.z = normalize( sub( look_at, camera.p ) );
    camera.x = normalize( cross( camera.z, p3(0,1,0) ) );
    camera.y = normalize( cross( camera.x, camera.z ) );
}

function pointInRect( p, rect ) {
    return p.x > rect.x && p.x < ( rect.x + rect.width ) &&
           p.y > rect.y && p.y < ( rect.y + rect.height );
}

function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');

    depth = 2;
    mirror_lists = getMirrorLists( 2*depth + 1, depth );

    sliders = [];
    sliders[0] = { x: 10, y:10, width:canvas.width-20, height:20, value:sliderPosFromCurvature(1), handle_rect:{} };
    sliders[1] = { x: 10, y:40, width:canvas.width-20, height:20, value:sliderPosFromCurvature(0), handle_rect:{} };
    sliders[2] = { x: 10, y:70, width:canvas.width-20, height:20, value:0, handle_rect:{} };
    isActiveSlider = -1;
    
    // parse the parameters from the URL
    if( window.location.search.length > 0 ) {
        var params = window.location.search.match( /f\d=[\d\.-]+/g );
        if( params.length <= sliders.length ) {
            for( var iSlider = 0; iSlider < sliders.length; ++iSlider ) 
                sliders[ iSlider ].value = 0; // effectively turn this one off until we hear otherwise
            for( var iParam = 0; iParam < params.length; ++iParam )
                sliders[ iParam ].value = sliderPosFromCurvature( params[ iParam ].split('=')[1] );
        }
    }
    updateShareLink();

    theta = Math.PI / 2;
    camera = { p:p3(0,3,-6),
               x:p3(1,0,0), 
               y:p3(0,1,0), 
               z:p3(0,0,1), 
               f:canvas.height,
               pp:p2(canvas.width/2,canvas.height/2) 
             };
    repositionCamera();
    
    makeMesh();

    redraw();

    canvas.addEventListener( 'mousemove', onMouseMove, false );
    canvas.addEventListener( 'touchmove', onMouseMove, false );
    canvas.addEventListener( 'touchstart', onMouseDown, false );
    canvas.addEventListener( 'mousedown',  onMouseDown, false );
    canvas.addEventListener( 'touchend', onMouseUp, false );
    canvas.addEventListener( 'mouseup',  onMouseUp, false );
    canvas.addEventListener( 'mouseout',  onMouseUp, false );
    
    animate();
}

function sphereInversion( p, sphere ) {
    var d2 = len2( sub( p, sphere.p ) );
    return add( sphere.p, mul( sub( p, sphere.p ), sphere.r2 / d2 ) );
}

function sphereInversion4d( p, sphere ) {
    var d2 = Math.pow( p.x - sphere.p.x, 2 ) + Math.pow( p.y - sphere.p.y, 2 ) + Math.pow( p.z - sphere.p.z, 2 ) + Math.pow( p.w - sphere.p.w, 2 );
    var mf = sphere.r2 / d2;
    return { x: sphere.p.x + mf*(p.x-sphere.p.x), y: sphere.p.y + mf*(p.y-sphere.p.y), z: sphere.p.z + mf*(p.z-sphere.p.z), w: sphere.p.w + mf*(p.w-sphere.p.w) };
}

function planeReflection( p, plane ) {
    var pn = dot( plane.n, sub( p, plane.p ) );
    var proj = sub( p, mul( plane.n, pn ) );
    return add( proj, sub( proj, p ) );
}

function pointReflection( p, point ) {
    return add( point.p, sub( point.p, p ) );
}

function camera_projection( p, camera ) {
    var ray = sub( p, camera.p ); // the ray from camera center to point
    var cp = p3( dot( camera.x, ray ), dot( camera.y, ray ), dot( camera.z, ray ) ); // into camera space
    return p2( cp.x * camera.f / cp.z + camera.pp.x, 
               cp.y * camera.f / cp.z + camera.pp.y ); // pinhole projection
}

function redraw() {
    drawMesh();
    drawUI();
}

function drawMesh() {

    // project the mesh onto the screen
    var face_list = [];
    for( var iPolyhedron = 0; iPolyhedron < mesh.length; ++iPolyhedron ) {
        var polyhedron = mesh[ iPolyhedron ];
        for( var iPolygon = 0; iPolygon < polyhedron.length; ++iPolygon ) {
            var polygon = polyhedron[ iPolygon ];
            var vertex_list = new Array( polygon.length );
            for( var iVert = 0; iVert < polygon.length; ++iVert ) {
                vertex_list[ iVert ] = camera_projection( polygon[ iVert ], camera );
            }
            face_list.push( vertex_list );
        }
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeRect(0, 0, canvas.width, canvas.height);

    // draw the mesh
    // (first the faces, then the edges, else the wrong z-ordering breaks things)
    ctx.fillStyle = "rgba(200,210,255,0.1)";
    for( var iFace = 0; iFace < face_list.length; ++iFace ) {
        var face = face_list[ iFace ];
        ctx.beginPath();
        ctx.moveTo( face[0].x, face[0].y );
        for( var iVert = 1; iVert < polygon.length; ++iVert ) {
            ctx.lineTo( face[ iVert ].x, face[ iVert ].y );
        }
        ctx.fill();
    }
    ctx.strokeStyle = "rgba(0,0,0,0.5)";
    ctx.beginPath();
    for( var iFace = 0; iFace < face_list.length; ++iFace ) {
        var face = face_list[ iFace ];
        ctx.moveTo( face[0].x, face[0].y );
        for( var iVert = 1; iVert < polygon.length; ++iVert ) {
            ctx.lineTo( face[ iVert ].x, face[ iVert ].y );
        }
    }
    ctx.stroke();
}

function drawRect( x, y, w, h ) {
    ctx.beginPath();
    ctx.rect( x, y, w, h );
    ctx.fill();
    ctx.stroke();
}

function sign( x ) {
    return x?x<0?-1:1:0;
}

function drawUI() {
    // draw the sliders
    ctx.strokeStyle="rgb(0,0,0)";
    for( var iSlider = 0; iSlider < sliders.length; ++iSlider ) {
        var slider = sliders[ iSlider ];
        ctx.fillStyle="rgb(255,255,255)";
        drawRect( slider.x, slider.y + slider.height/3, slider.width, slider.height/3 ); // rail
        if( iActiveSlider == iSlider )
            ctx.fillStyle="rgb(100,100,255)";
        var handle_radius = 5;
        slider.handle_rect = { x:slider.x+slider.width*slider.value-handle_radius, y:slider.y, width:handle_radius*2+1, height:slider.height };
        drawRect( slider.handle_rect.x, slider.handle_rect.y, slider.handle_rect.width, slider.handle_rect.height );
    }

    // display some properties of this shape
    
    ctx.font="14px Arial";
    ctx.fillStyle="rgba(0,0,0,0.4)";
    ctx.textAlign = "left";
    ctx.textBaseline = "bottom";

    var f1 = curvatureFromSliderPos( sliders[0].value );
    var r1 = 1.0 / f1;
    var f2 = curvatureFromSliderPos( sliders[1].value );
    var r2 = 1.0 / f2;
    var f3 = curvatureFromSliderPos( sliders[2].value );
    var r3 = 1.0 / f3;

    ctx.fillText( "Curvature: "+f1.toFixed(3)+", "+f2.toFixed(3)+", "+f3.toFixed(3)+", ", 20, canvas.height-20 );
                              
    var radii_text = "Polygon radius: "+r1.toFixed(3);
    if( r2 > 0 ) 
        radii_text += "     Polyhedron radius: "+r2.toFixed(3);
    if( r3 > 0 ) 
        radii_text += "     Polychoron radius: "+r3.toFixed(3);
    radii_text += "     (edge length is 1)";    
    ctx.fillText( radii_text, 20, canvas.height-50 );
    
    var edge_length = 1.0; // fixed
    var v = edge_length / 2.0; // distance from center of edge to rotation point
    var m1 = Math.sqrt( r1*r1 - v*v ); // distance from polygon center to edge midpoint
    var corner_angle = ( 180.0 / Math.PI ) * 2.0 * Math.acos( v / r1 );
    var exterior_angle = 180.0 - corner_angle;
    var schlafli1 = 360.0 / exterior_angle; // proportion of number of sides to connection distance
    // regular polygons are N/1 = N, star polygons are N/M (e.g. pentagram = 5/2 = 2.5 )

    var m2 = Math.sqrt( r2*r2 - v*v ); // distance from polyhedron center to edge midpoint (if in 3D)
    var dihedral_angle = ( 180.0 / Math.PI ) * 2.0 * Math.acos( m1 / m2 * sign( r2 ) );
    var theta; // what is the extra angle caused by the bulging in or out at a vertex?
    if( Math.abs(f2) < 1e-4 ) {
        theta = 0.0;
    }
    else if( r2 > 0.0 ) {
        var r2_in_the_plane = getInversionRadiusForStereographicPolyhedron( p3(0,m1,0), p3(-v,0,0), p3(v,0,0), r2 );
        theta = ( 180.0 / Math.PI ) * Math.asin( v / r2_in_the_plane );
    }
    else { 
        theta = ( 180.0 / Math.PI ) * Math.asin( v / r2 );
    }
    var psi = corner_angle + 2.0 * theta; // psi is the new corner angle after bulging in or out
    var schlafli2 = 360.0 / psi; // how many polygons will fit around a vertex?
    
    var psi3; // what is the dihedral angle in the bulged polyhedra?
    if( Math.abs(f3) < 1e-4 ) {
        psi3 = dihedral_angle;
    }
    else if( r3 > 0.0 ) {
        var h = Math.sqrt( m2*m2 - m1*m1 ); // height of the polyhedron center above the polygon face, check: h == Math.sqrt(r2*r2-r1*r1)
        var cc = p3(0,m1,h); // polyhedron center
        var c = p3(0,m1,0); // polygon center
        var p = p3(v,0,0); // a vertex
        var r3_stereo = getInversionRadiusForStereographicPolychoron( cc, c, p, r3 );
        var pch = Math.sqrt( r3_stereo*r3_stereo - r1*r1 ); // height of the center of the inversion sphere above the polygon face
        var q = pch - h; // distance from polyhedron center to inversion sphere center
        var d = 2.0 * ( m1 * q / m2 ); // separation of inversion sphere centers, because triangle cc:c1:mp is similar to cc:(ccc1+ccc2)/2:ccc1
        psi3 = ( 180.0 / Math.PI ) * 2.0 * Math.acos( d / ( 2.0 * r3_stereo ) );
    }
    else { 
        var h = Math.sqrt( m2*m2 - m1*m1 );
        var cc = p3(0,m1,h); // polyhedron center
        var c = p3(0,m1,0); // polygon center
        var p = p3(v,0,0); // a vertex
        var mp = p3(0,0,0);
        var pch = -Math.sqrt( r3*r3 - r1*r1 ); // height of the center of the inversion sphere above the polygon face
        var q = pch - h; // distance from polyhedron center to inversion sphere center
        var d = 2.0 * ( m1 * q / m2 ); // separation of inversion sphere centers, because triangle cc:c1:mp is similar to cc:(ccc1+ccc2)/2:ccc1
        psi3 = ( 180.0 / Math.PI ) * 2.0 * Math.acos( d / ( 2.0 * r3 ) );
    }
    var schlafli3 = 360.0 / psi3; // how many polyhedra will fit around each edge?
    
    var angles_text = "Corner angle when flat: "+corner_angle.toFixed(2)+"\xB0     Corner angle: "+psi.toFixed(2)+"\xB0";
    if( r2 > 0.0 ) {
        angles_text += "     Dihedral angle when flat: "+dihedral_angle.toFixed(2)+"\xB0";
        angles_text += "     Dihedral angle: "+psi3.toFixed(2)+"\xB0";
    }
    ctx.fillText( angles_text, 20, canvas.height-80 );
    
    ctx.fillText( "Schlafli symbol: { "+schlafli1.toFixed(2)+", "+schlafli2.toFixed(2)+ ", "+schlafli3.toFixed(2)+ " }",20,canvas.height-110);
    
    // TODO: mark interesting places on the sliders
    
    // interesting links:
    // http://en.wikipedia.org/wiki/Angular_defect
    // http://hddb.teamikaria.com/forum/viewtopic.php?f=3&t=1563
    // http://gregegan.customer.netspace.net.au/SCIENCE/Dihedral/Dihedral.html
    // http://en.wikipedia.org/wiki/Table_of_polyhedron_dihedral_angles
}

function animate() {
    if( isSpinning ) {
        // rotate round
        theta += 0.01;
        repositionCamera();
        redraw();
        requestAnimationFrame( animate );
    }
}

function updateShareLink() {
    var new_url = window.location.protocol + '//' + window.location.host + window.location.pathname + "?";
    for( var iSlider = 0; iSlider < sliders.length; ++iSlider ) {
        if( iSlider > 0)
            new_url += "&";
        new_url += "f" + iSlider + "=" + curvatureFromSliderPos( sliders[ iSlider ].value ).toFixed(3);
    }
    document.getElementById('link').innerHTML = "Share the link directly to this shape: <a href=\""+new_url+"\">"+new_url+"</a>";
}

window.onload = init;
</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

</head>

<body>

<p align="center"><canvas id="canvas" width="1000" height="600">(Canvas drawing not supported by your browser.)</canvas></p>

<div id="link">link</div>

There are lots of links to interesting shapes here: <a href="https://github.com/timhutton/hyperplay/wiki">https://github.com/timhutton/hyperplay/wiki</a>

<p><b>OK the heck am I looking at this time?</b></p>
<ul>
<li>In the center is a line segment of unit length. It never changes.
<li>We make copies of it, at different angles. Slider 1 controls the curvature. By default it makes a hexagon.
<li>We then make copies of the resulting polygon by reflecting it in its edges. Slider 2 controls the curvature of that.
<li>We then make copies of the resulting polyhedron by reflecting it in its faces. Slider 3 controls the curvature of that.
<li>More information and links here: <a href="https://github.com/timhutton/hyperplay">https://github.com/timhutton/hyperplay</a> (and a simpler version of this! gosh, I don't blame you)
<li>Click on the image to start/stop the spinning.
</ul>

<p>TODO:</p>
<ul>
<li>Allow recursion depth at each level to be controlled.
<li>Better rendering!
</ul>

</html>

