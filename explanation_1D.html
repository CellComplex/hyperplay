<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<script>

var MirrorType = { SPHERE:1, PLANE:2, POINT:3 };

function p3( x, y, z ) { return { x:x, y:y, z:z }; }
function p2( x, y ) { return { x:x, y:y }; }
function add( a, b ) { return p3( a.x + b.x, a.y + b.y, a.z + b.z ); }
function sub( a, b ) { return p3( a.x - b.x, a.y - b.y, a.z - b.z ); }
function mul( a, f ) { return p3( a.x * f, a.y * f, a.z * f ); }
function dot( a, b ) { return a.x * b.x + a.y * b.y + a.z * b.z; }
function len2( a ) { return dot(a,a); }
function dist( a, b ) { return Math.sqrt( len2( sub( a, b ) ) ); }
function assign( a, b ) { a.x = b.x; a.y = b.y; a.z = b.z; }
function normalize( a ) { return mul( a, 1 / Math.sqrt( len2( a ) ) ); }
function cross( a, b ) { return p3( a.y * b.z - a.z * b.y, a.z*b.x - a.x * b.z, a.x * b.y - a.y * b.x ); }
function circle_radius( a, b, c ) { return a*b*c / Math.sqrt( (a+b+c)*(-a+b+c)*(a-b+c)*(a+b-c) ); } // triangle with side lengths a,b,c

var canvas;
var ctx;
var f;
var scale;
var translate;

function reflect( p, mirror ) {
    switch( mirror.type ) {
        case MirrorType.SPHERE:
            return sphereInversion( p, mirror );
        case MirrorType.PLANE:
            return planeReflection( p, mirror );
        case MirrorType.POINT:
            return pointReflection( p, mirror );
    }
}


function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return p2( evt.clientX - rect.left, evt.clientY - rect.top );
}

function onMouseMove( evt ) {
    var pos = getMousePos( canvas, evt );
    f = ( pos.x - canvas.width/2 ) * 0.5;
    redraw();
}

function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');

    f = 1.0;
    scale = 100.0;
    translate = p3( canvas.width/2, canvas.height/2, 0 );
    redraw();

    canvas.addEventListener( 'mousemove', onMouseMove, false );
}

function sphereInversion( p, sphere ) {
    var d2 = len2( sub( p, sphere.p ) );
    return add( sphere.p, mul( sub( p, sphere.p ), sphere.r2 / d2 ) );
}

function planeReflection( p, plane ) {
    var pn = dot( plane.n, sub( p, plane.p ) );
    var proj = sub( p, mul( plane.n, pn ) );
    return add( proj, sub( proj, p ) );
}

function pointReflection( p, point ) {
    return add( point.p, sub( point.p, p ) );
}

function line( a, b ) { 
    ctx.beginPath();
    ctx.moveTo( a.x*scale + translate.x, a.y*scale + translate.y ); 
    ctx.lineTo( b.x*scale + translate.x, b.y*scale + translate.y ); 
    ctx.stroke();
}
function circle( c, R ) { ctx.beginPath(); ctx.arc( c.x*scale + translate.x, c.y*scale + translate.y, Math.abs(R)*scale, 0, 2.0 * Math.PI ); ctx.stroke(); }
function point( p, t ) { 
    ctx.beginPath(); 
    ctx.arc( p.x*scale + translate.x, p.y*scale + translate.y, 2, 0, 2.0 * Math.PI ); 
    if( t )
        ctx.fillText( t, p.x*scale + translate.x + 3, p.y*scale + translate.y - 3 );
    ctx.fill(); 
}

function redraw() {
    ctx.clearRect( 0, 0, canvas.width, canvas.height );
    ctx.strokeRect( 0, 0, canvas.width, canvas.height );
    
    ctx.strokeStyle = "rgba(0,0,0,0.3)";
    ctx.font="12px Verdana";
    
    // draw the base line
    line( p3(-100,0,0), p3(100,0,0) );
    ctx.beginPath();
    ctx.fillText( 'input plane', 10, translate.y - 3 );

    
    var R = 1.0 / f;
    if( R < 0 ) return; // ignore negative curvature for now
    R *= 100;

    // edge of unit length along the x-axis, centered at the origin
    var p = p3(0.5,0,0);
    var p2 = p3(-0.5,0,0);
    
    // construct the circumcircle that the polygon will lie on
    var v = dist( p, p3(0,0,0) );
    var h = Math.sqrt( R*R - v*v );
    var c = p3( 0, -h, 0 );
    circle( c, R );
    
    // construct the inversion circle that we can use to project stereographically to and from the circumcircle
    var SR = 2.0 * R;
    var sc = p3( 0, -(h+R), 0 );
    var inversion = { type:MirrorType.SPHERE, p:sc, r2:SR*SR };
    circle( sc, SR );
    
    point( p, 'A' );
    point( p2, 'B' );
    point( c, 'C' );
    point( sc, 'S' );
    
    // draw the stereographic plane
    line( p3( -100, R-h, 0 ), p3( 100, R-h, 0 ) );
    
    // construct the antipodal point on the circle and on the plane
    var ap = add( c, sub( c, p ) );
    var pap = reflect( ap, inversion );
    var opap = add( sc, mul( sub( pap, sc ), (h+R)/(R+R) ) );
    point( ap, 'X' );
    point( pap );
    point( opap, 'Y' );
    
    // show the construction lines that got us from p to opap
    line( p, sc );
    line( p, ap );
    line( sc, pap );
    
    // find the center and radius of the inversion circle for point p on our input plane
    var ic = mul(add(p,opap),0.5);
    var ir = dist(p,ic);
    point( ic, 'K' );
    
    // show the effect of the mirrors we've made
    var mirror2D = { type:MirrorType.PLANE, p:c, n:normalize(p3(-(p.y-c.y),p.x-c.x,0)) };
    var mirror1D = { type:MirrorType.SPHERE, p:ic, r2:ir*ir };
    var p2r1D = reflect( p2, mirror1D );
    var p2r2D = reflect( p2, mirror2D );
    point( p2r1D, 'P' );
    point( p2r2D, 'Q' );
    line( sc, p2r1D );
    line( p2, p2r2D );
    
    // draw the polygon parts in bold
    ctx.strokeStyle = "rgba(0,0,0,1)";
    line( p2, p );
    line( p, p2r2D );
}

window.onload = init;
</script>

<noscript>
<p>For full functionality of this site it is necessary to enable JavaScript.
Here are the <a href="http://www.enable-javascript.com/" target="_blank">
instructions how to enable JavaScript in your web browser</a>.
</p></noscript>

</head>

<body>

<p align="center"><canvas id="canvas" width="1000" height="400">(Canvas drawing not supported by your browser.)</canvas></p>

<p>A line segment becomes a polygon. This construction relates the normal 2D view and the corresponding stereographic projection<p>
<ul>
<li><b>BA</b> is our starting point, an edge of unit length lying on the input plane but also on the spherical space.
<li>For a desired radius R we can find the polygon center <b>C</b> where R=BC=AC.
<li>Wythoff construction is a reflection across the line <b>AC</b>. Reflecting point <b>B</b> across this line gives us <b>Q</b>, the 
next point on our polygon.
<li>If we want to stay in 1D then we can use stereographic projection. The mapping from one to the other is given by circle inversion 
around point <b>S</b> with radius 2AC. That puts us onto the wrong plane but we can easily get back to the input plane by linear scaling.
<li>Our Wythoff reflection is now a 'circle' of inversion in the input plane with center <b>K</b> and radius AK=KY, mapping <b>B</b> onto <b>P</b>. 
Note that <b>P</b> is also the sterographic projection of <b>Q</b>, which is what we want.
<li>That inversion circle is defined by its two fixed points: <b>A</b> and <b>Y</b>, the stereographic projection of <b>X</b>, <b>A</b>'s antipode.
This is because all points on the line <b>AC</b> will be unaffected by the reflection.
</ul>

<p>In higher dimensions this construction becomes useful. For making polyhedra on the stereographic plane:
<ul>
<li><b>A</b> is now an edge of the polygon seen sideways-on and <b>AC</b> is the plane of reflection for producing the next face in the circumsphere around <b>C</b>.
<li>The plane <b>AC</b> intersects the circumsphere at a circle of points, which projects onto the inversion circle we want on the input plane.
<li>That circle is defined by the end points at <b>A</b> and the projection of their antipodes at <b>Y</b>. The center <b>K</b> is no longer 
halfway between them as in the 1D case but is still defined by passing through all the fixed points.
</ul>

<p>For making polychora on the stereographic volume:
<ul>
<li><b>A</b> is now the face of a polyhedron squashed into a point, and <b>AC</b> is the hyperplane of reflection for producing the next cell.
<li>That hyperplane intersects the 3-sphere at a 2-sphere, and the projection of this 2-sphere is the sphere of inversion we want.
<li>We can construct the sphere of inversion using sphere fitting to the points at <b>A</b> and the projection of their antipodes at <b>Y</b>.
</ul>

</html>

